/*
Fail:
  #define MIN_SINGLE_INCREASE 5
  #define MIN_TOTAL_INCREASE 15
  #define MIN_SINGLE_DECREASE (0)
  #define MIN_TOTAL_DECREASE (-12)
  #define MAX_TOUCH_DURATION 4
  #define SAMPLING_COUNT 25

Fail:
  #define MIN_SINGLE_INCREASE 5
  #define MIN_TOTAL_INCREASE 19
  #define MIN_SINGLE_DECREASE (0)
  #define MIN_TOTAL_DECREASE (-13)
  #define MAX_TOUCH_DURATION 4
  #define SAMPLING_COUNT 25
*/



//Works with 5MOhm:
void testCapSense() {
  // Working values: Total increase 20, total decrease -15 (no singles) had no false positives. A little hard to trigger
  #define MIN_TOTAL_INCREASE 20
  #define MIN_TOTAL_DECREASE (-15)
  #define MAX_TOUCH_DURATION 4
  #define SAMPLING_COUNT 25

  long currentMs = 0;
  long endTime = 0;
  long lastLastReading = 0;
  long lastReading = 0;
  long curReading = 0;
  uint8_t bufferIndex = 0;
  uint8_t increaseHappened = 0;
  int32_t derivative = 0;
  
  bool touchIsValid = false;
  bool needsReset = true;
  
  while(1) {
    if(needsReset) {
      // Reset state
      touchIsValid = false;
      needsReset = false;
      increaseHappened = 0;
      curReading = touchSensor.capacitiveSensorRaw(SAMPLING_COUNT);
      lastReading = curReading;
      lastLastReading = lastReading;
    }
    
    curReading = touchSensor.capacitiveSensorRaw(SAMPLING_COUNT);
    derivative = (curReading - lastReading) + (lastReading - lastLastReading);
    lastLastReading = lastReading;
    lastReading = curReading;
    if(increaseHappened == 0) {
      // Waiting for a touch
      if(derivative >= MIN_TOTAL_INCREASE)
      {
        increaseHappened = MAX_TOUCH_DURATION;
      }
    }
    else {
      // Touch recently happened, check for a non-touch
      if(derivative <= MIN_TOTAL_DECREASE)
      {
        touchIsValid = true;
      }
      increaseHappened--;
    }

    // Pressing the button also counts as a valid "touch"
    if(!digitalRead(BUTTON_PIN)) {
      delayCycles(DEBOUNCE_DELAY);
      if(!digitalRead(BUTTON_PIN)) {
        touchIsValid = true;
      }
    }
    
    if(touchIsValid) {
      // Touch or button press occurred, blink the LEDs for a bit
      currentMs = millis();
      endTime = currentMs + POWER_DURATION_MS;
      while(endTime > currentMs) {
        setLeds(true, false, FULL_BRIGHTNESS, 6);
        setLeds(false, false, OFF, 6);
        setLeds(false, true, FULL_BRIGHTNESS, 6);
        setLeds(false, false, OFF, 6);
        currentMs = millis();
      }
      needsReset = true;
    }
  }
}

// Appears to work with 2MOhm, but haven't watched for false positives that long
void testCapSense() {
  // Working values: Total increase 20, total decrease -15 (no singles) had no false positives. A little hard to trigger
  #define MIN_SINGLE_INCREASE 7
  #define MIN_TOTAL_INCREASE 26
  #define MIN_SINGLE_DECREASE (0)
  #define MIN_TOTAL_DECREASE (-20)
  #define MAX_TOUCH_DURATION 4
  #define SAMPLING_COUNT 50

  long currentMs = 0;
  long endTime = 0;
  long lastLastReading = 0;
  long lastReading = 0;
  long curReading = 0;
  uint8_t bufferIndex = 0;
  uint8_t increaseHappened = 0;
  int32_t derivative = 0;
  
  bool touchIsValid = false;
  bool needsReset = true;
  
  while(1) {
    if(needsReset) {
      // Reset state
      touchIsValid = false;
      needsReset = false;
      increaseHappened = 0;
      curReading = touchSensor.capacitiveSensorRaw(SAMPLING_COUNT);
      lastReading = curReading;
      lastLastReading = lastReading;
    }
    
    curReading = touchSensor.capacitiveSensorRaw(SAMPLING_COUNT);
    derivative = (curReading - lastReading) + (lastReading - lastLastReading);
    lastLastReading = lastReading;
    lastReading = curReading;
    if(increaseHappened == 0) {
      // Waiting for a touch
      if(derivative >= MIN_TOTAL_INCREASE
        && curReading - lastLastReading >= MIN_SINGLE_INCREASE
        && lastReading - lastLastReading >= MIN_SINGLE_INCREASE)
      {
        increaseHappened = MAX_TOUCH_DURATION;
      }
    }
    else {
      // Touch recently happened, check for a non-touch
      if(derivative <= MIN_TOTAL_DECREASE
        && curReading - lastLastReading <= MIN_SINGLE_DECREASE
        && lastReading - lastLastReading <= MIN_SINGLE_DECREASE)
      {
        touchIsValid = true;
      }
      increaseHappened--;
    }

    // Pressing the button also counts as a valid "touch"
    if(!digitalRead(BUTTON_PIN)) {
      delayCycles(DEBOUNCE_DELAY);
      if(!digitalRead(BUTTON_PIN)) {
        touchIsValid = true;
      }
    }
    
    if(touchIsValid) {
      // Touch or button press occurred, blink the LEDs for a bit
      currentMs = millis();
      endTime = currentMs + POWER_DURATION_MS;
      while(endTime > currentMs) {
        setLeds(true, false, FULL_BRIGHTNESS, 4);
        setLeds(false, false, OFF, 8);
        setLeds(false, true, FULL_BRIGHTNESS, 4);
        setLeds(false, false, OFF, 8);
        currentMs = millis();
      }
      needsReset = true;
    }
  }
}

// To count the difference between touch and baseline:
// (noise as much as 10, a moderate touch ~35, a hard touch ~50 with 2MOhm)
void testCapSense() {
  #define SAMPLING_COUNT 50
  
  float baselineReading = 0;
  float touchReading = 0;
  float diff = 0;
  
  delayCycles(DELAY_XLONG);
  
  while(1) {
    if(!digitalRead(BUTTON_PIN)) {
      delayCycles(DELAY_XLONG);
      if(baselineReading == 0) {
        for(uint8_t i = 0; i < BRIGHTNESS_STEPS; i++) {
          setLeds(true, false, i, 3);
          delayCycles(DELAY_SHORT);
        }
        delayCycles(DELAY_XLONG);
        baselineReading = touchSensor.capacitiveSensorRaw(SAMPLING_COUNT);
        setLeds(true, false, FULL_BRIGHTNESS, 3);
        delayCycles(DELAY_XLONG);
        setLeds(false, false, OFF, 3);
      }
      else {
        delayCycles(DELAY_XLONG);
        for(uint8_t i = 0; i < BRIGHTNESS_STEPS; i++) {
          setLeds(true, false, BRIGHTNESS_STEPS-i, 3);
          delayCycles(DELAY_SHORT);
        }
        delayCycles(DELAY_XLONG);
        touchReading = touchSensor.capacitiveSensorRaw(SAMPLING_COUNT);
        
        if(touchReading > baselineReading) {
          diff = touchReading - baselineReading;
          while(diff > 0) {
            if(diff >= 10) {
              setLeds(true, true, FULL_BRIGHTNESS, 10);
              delayCycles(DELAY_XLONG);
              diff-=10;
            } else {
              setLeds(true, false, FULL_BRIGHTNESS, 10);
              delayCycles(DELAY_XLONG);
              diff-=1;
            }
            setLeds(false, false, OFF, 10);
            delayCycles(DELAY_XLONG);
            delayCycles(DELAY_XLONG);
          }
        }
        touchReading = 0;
        baselineReading = 0;
      }
    }
  }
}